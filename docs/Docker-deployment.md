# Конфигурация Docker для проекта Studio

## Введение

В этом документе описана система двух окружений, настроенная для проекта Studio:
1. **Локальная разработка** без Docker (с локальной базой данных)
2. **Продакшн-деплой** с использованием Docker (контейнеризированная база данных)

Такой подход обеспечивает быструю локальную разработку и надёжный деплой на сервер.

## Архитектура окружений

### 1. Локальная разработка

- **База данных**: `userstudio` на `localhost`
- **Пользователь БД**: `userstudio`
- **Пароль**: `userstudio`
- **Настройки**: файл `.env.local` (имеет приоритет над `.env`)
- **Запуск**: `npm run dev`

### 2. Docker-деплой

- **База данных**: `studio_db` на хосте `db` (имя сервиса в Docker)
- **Пользователь БД**: `postgres`
- **Пароль**: `postgres` (для продакшн рекомендуется изменить)
- **Настройки**: файл `.env` + переменные окружения Docker
- **Запуск**: `docker-compose up -d`

## Автоматическое определение окружения

Проект настроен на автоматическое определение окружения запуска:

1. **Ключевые файлы**:
   - `src/lib/models/index.ts` - проверяет переменную `DOCKER_ENV`
   - `Dockerfile` - устанавливает `DOCKER_ENV=true`
   - `docker-compose.yml` - передает `DOCKER_ENV=true` в контейнер

2. **Механизм работы**:
   ```typescript
   // Определяем, запущено ли приложение в Docker
   const isRunningInDocker = process.env.DOCKER_ENV === 'true';
   
   // Определяем хост базы данных автоматически
   const dbHost = isRunningInDocker ? 'db' : (process.env.DB_HOST || 'localhost');
   ```

## Каскадная загрузка переменных окружения

Next.js использует каскадное переопределение переменных окружения:

1. `.env.local` - высший приоритет, применяется во всех окружениях
2. `.env.[окружение].local` - например, `.env.development.local`
3. `.env.[окружение]` - например, `.env.development`
4. `.env` - базовый файл с наименьшим приоритетом

В проекте:
- **Локальная разработка**: `.env.local` переопределяет настройки БД из `.env`
- **Docker-деплой**: `.env.local` отсутствует в контейнере, используется `.env`

## Настройка переменных окружения

### .env.local (локальная разработка)

```ini
# Переменные для конфигурации локальной базы данных
DB_NAME=userstudio
DB_USERNAME=userstudio
DB_PASSWORD=userstudio
DB_HOST=localhost
DB_PORT=5432
DB_DIALECT=postgres

# Переопределяем DATABASE_URL для локальной разработки
DATABASE_URL=postgres://userstudio:userstudio@localhost:5432/userstudio
```

### .env (Docker-деплой)

```ini
# Настройки базы данных
DATABASE_URL=postgres://postgres:postgres@db:5432/studio_db

# Переменные для конфигурации базы данных
DB_NAME=studio_db
DB_USERNAME=postgres
DB_PASSWORD=postgres
DB_HOST=db
DB_PORT=5432
DB_DIALECT=postgres

# Переменные для контейнера PostgreSQL
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=studio_db

# Настройки приложения
NODE_ENV=production
NEXT_PUBLIC_API_URL=http://YOUR_DOMAIN_OR_IP
```

## Рабочий процесс разработки и деплоя

### Локальная разработка

1. Убедитесь, что локальная PostgreSQL запущена
2. Создайте базу данных `userstudio` с пользователем `userstudio`
3. Запустите `npm run dev` для запуска проекта

### Тестирование Docker-конфигурации локально

1. Запустите `docker-compose up -d`
2. Проверьте работу приложения через браузер
3. Остановите контейнеры `docker-compose down`

### Деплой на сервер

1. Запустите `node scripts/prepare-deploy.js` для создания архива
2. Скопируйте архив на сервер
3. Используйте `scripts/docker-deploy.sh` для развертывания

## Преимущества двух окружений

- **Безопасность данных**: изолированные окружения предотвращают случайное удаление продакшн-данных
- **Независимость**: можно тестировать разные схемы и данные, не влияя на другую среду
- **Скорость разработки**: локальная разработка быстрее, не требует запуска контейнеров
- **Единый код**: нет необходимости менять код при переключении между режимами
- **Прозрачность**: в логах указывается, какое окружение используется

## Сценарии использования

1. **Ежедневная разработка**: локальная среда без Docker
2. **Тестирование деплоя**: локальный запуск в Docker
3. **Продакшн**: деплой на сервер через Docker
